{"pages":[{"title":"","date":"2017-05-27T14:57:38.297Z","updated":"2017-05-27T14:57:38.297Z","comments":true,"path":"README.html","permalink":"http://yoursite.com/README.html","excerpt":"","text":"###欢迎进入我的博客"}],"posts":[{"title":"响应式的头与兼容IE引用","slug":"Responsive-header","date":"2017-05-27T22:28:35.000Z","updated":"2017-05-28T06:36:38.105Z","comments":true,"path":"2017/05/28/Responsive-header/","link":"","permalink":"http://yoursite.com/2017/05/28/Responsive-header/","excerpt":"","text":"最近开始设计个人网站，又重新回到响应式的学习上。 以下是我的网站的代码头。首先是bootstrap的引用123&lt;!-- Bootstrap --&gt;&lt;link href=&apos;&apos;css/bootstrap.min.css&apos;&apos; rel=&apos;&apos;stylesheet&apos;&apos;&gt;&lt;link href=&apos;&apos;css/bootstrap-theme.min.css&apos;&apos; rel=&apos;&apos;stylesheet&apos;&apos;&gt; 接下来是bootstrap的JS组件，由于其依赖于JQuery库，所以同时在文档底引入JQuery库： 注意：顺序不要换，不然会报错12345&lt;!-- jquery (neccessary for Bootstrap&apos;s JavaScript plugins) --&gt;&lt;script src=&apos;&apos;https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js&apos;&apos;&gt;&lt;/script&gt;&lt;!-- Include all complied plugins(below), or include individual files as needed --&gt;&lt;script src=&apos;&apos;js/bootstrap.min.js&gt;&lt;/script&gt; 紧接着是IE系的兼容性解决：1234567&lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&gt;&lt;!-- WARNING : Respond.js doesn&apos;t work if you view the page via file:// --&gt;&lt;!-- [ if it IE 9 ] &gt; &lt;script src=&apos;&apos;https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js&gt;&lt;/script&gt; &lt;script src=&apos;&apos;https://oss.maxcdn.com/respond/1.4.2/respond.min.js&gt;&lt;/script&gt;&lt;! [ endif ] --&gt; html5shiv–百度百科和respond.js分别对应于解决html5新元素于css3的media query问题。 最后贴下我的元标签：123&lt;meta charset=&apos;&apos;utf-8&apos;&apos;&gt;&lt;meta http-equiv=&apos;&apos;X-UA-Compatible&apos;&apos; content=&apos;&apos;IE=edge&apos;&apos;&gt;&lt;meta name=&apos;&apos;viewport&apos;&apos; content=&apos;&apos;width=device-width,initial-scale=1&apos;&apos;&gt; X-UA-Compatible用于告诉IE8该用何种方式渲染文档，其值IE-edge指代用最新的引擎渲染网页。另外还有值chrome=1用于激活chrome frame。（参考Sivan’ Blog）这三条必须放在head中的最靠前，其它标签在其后。 好了，就是这些了，谢谢阅读~~~ 补充1：由于google在国内被墙的原因，google提供的公共库没办法访问，包括以下（由于一直挂着VPN，所以没有感受….蛋疼） ajax.googleapis.com - 前端公共库fonts.googleapis.com - 免费字体库themes.googleusercontent.com - fonts 有时会使用到这个里面的资源 上述的ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.jsCDN服务，我选择下载下来使用。如果是访问使用了google CDN服务的网页需要提速的话，这里有一个github上的开源插件可以用，名字是 Replace Google CDN.","categories":[{"name":"赛先生","slug":"赛先生","permalink":"http://yoursite.com/categories/赛先生/"}],"tags":[]},{"title":"JQuery.getJSON","slug":"getJSON","date":"2017-05-19T15:30:13.000Z","updated":"2017-05-28T07:52:14.901Z","comments":true,"path":"2017/05/19/getJSON/","link":"","permalink":"http://yoursite.com/2017/05/19/getJSON/","excerpt":"","text":"描述：一篇关于JQuery文档的译稿 使用 &quot;GET&quot; HTTP请求从服务器导入JSON格式数据。 123456789101112JQuery.getJSON(url [,data] [,success])url类型：字符串一个包含发送请求的链接data类型：一般对象（[PlainObject](http://api.jquery.com/Types/#PlainObject)）或字符串根据请求被发送至服务器的一般对象或字符串success类型：函数对象请求成功执行的函数 它是一个缩略的Ajax函数，等价于：123456 $.ajax(&#123; dataType: &quot;json&quot;, url: url, data: data, success: success&#125;); 发送给服务器的Data会被附加至URL作为查询字符串。如果data的参数值是一个一般对象，在被附加至URL之前会被转换为字符串和URL编码形式。 大多数工具都会制定一个成功函数：1234567891011$.getJSON( &quot;ajax/test.json&quot;, function( data ) &#123; var items = []; $.each( data, function( key, val ) &#123; items.push( &quot;&lt;li id=&apos;&quot; + key + &quot;&apos;&gt;&quot; + val + &quot;&lt;/li&gt;&quot; ); &#125;); $( &quot;&lt;ul/&gt;&quot;, &#123; &quot;class&quot;: &quot;my-new-list&quot;, html: items.join( &quot;&quot; ) &#125;).appendTo( &quot;body&quot; );&#125;); 这个例子依赖于JSON文件的结构：12345&#123; &quot;one&quot;: &quot;Singular sensation&quot;, &quot;two&quot;: &quot;Beady little eyes&quot;, &quot;three&quot;: &quot;Little birds pitch by my doorstep&quot;&#125; 根据这种结构，上面这个例子遍历得到的数据，然后建立一个无序列表，添加至body元素内。 success回调传入的返回的数据，该数据根据JSON结构来定义，是典型地一个JS对象或数组，然后使用parseJSON（）方法来转换。该函数也能响应文本格式。 在JQuery 1.5 中，成功函数接收一个“jqXHR” 对象（在JQuery 1.4中，它接收XMLHTTPObject对象）。然后，因为JSONP和跨域的GET请求不使用XHR，所以在这样的案例中传入成功函数的jqXHR和textStatus属于未定义。 重要： 在JQuery 1.5 中，如果JSON文件包含一个语法错误，请求通常会默默失败，避免因为这个原因而频繁地手动修改JSON数据。JSON这种数据交换格式，拥有比其它JS对象的文字记法严格的多的语法规则。例如，JSON中的所有字符串，无论是属性还是值，都必须用双引号引起。查询更多JSON格式的语法细节，请参考：http://json.org/. JSONP 如果传入的URL包括字符串“callback=?”（或类似的，由服务器API定义的），该请求会被替代为JSONP请求。参考$.ajax()中有关JSONP的讨论获得更多细节。 jqXHR对象 在JQuery 1.5 中，所有的JQuery Ajax 方法都会返回一个XMLHTTPObject对象的超集。这个JQuery XHR对象，即jqXHR，由$.getJSOn，Promise接口返回，返回一个Promise全部的属性，方法和行为（参阅： Deferred object）。jqXHR.done()（用于成功），jqXHR.fail()（用于错误）和jqXHR.always()（用于完成，无论成功与否，于JQuery 1.6添加）都会在请求结束时传入一个函数作为参数执行。关于这个函数接收的参数的更多信息，请参阅$.ajax文档的jqXHR Object 一节。 JQuery 1.5的Promise接口允许JQuery Ajax 方法，包括$.getJSON()，在一个请求中，链式添加.done()，.always()，和.fail()回调，甚至在请求可能完成时分配这些回调。如果请求已经完成，回调会被立即清除。123456789101112131415161718192021// Assign handlers immediately after making the request,// and remember the jqxhr object for this requestvar jqxhr = $.getJSON( &quot;example.json&quot;, function() &#123; console.log( &quot;success&quot; );&#125;) .done(function() &#123; console.log( &quot;second success&quot; ); &#125;) .fail(function() &#123; console.log( &quot;error&quot; ); &#125;) .always(function() &#123; console.log( &quot;complete&quot; ); &#125;); // Perform other work here ... // Set another completion function for the request abovejqxhr.complete(function() &#123; console.log( &quot;second complete&quot; );&#125;); 清除说明： jqXHR.success()，jqXHR.error()和jqXHR.complete已经在JQuery 3.0中被移除，取而代之的是jqXHR.done()，jqXHR.fail()，jqXHR.always()。 附加说明： 因为浏览器的安全限制，大多“Ajax”请求都是同源策略的对象：请求不会成功取回来自不同域，子域，端口或协议的数据。 Script和JSONP请求不是同源策略的对象。 例子：使用 Flicker JSONP API 导入四张最近关于Mount Rainer 的图片1234567891011121314151617181920212223242526272829303132333435363738&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;jQuery.getJSON demo&lt;/title&gt; &lt;style&gt; img &#123; height: 100px; float: left; &#125; &lt;/style&gt; &lt;script src=&quot;https://code.jquery.com/jquery-1.10.2.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;images&quot;&gt;&lt;/div&gt; &lt;script&gt;(function() &#123; var flickerAPI = &quot;http://api.flickr.com/services/feeds/photos_public.gne?jsoncallback=?&quot;; $.getJSON( flickerAPI, &#123; tags: &quot;mount rainier&quot;, tagmode: &quot;any&quot;, format: &quot;json&quot; &#125;) .done(function( data ) &#123; $.each( data.items, function( i, item ) &#123; $( &quot;&lt;img&gt;&quot; ).attr( &quot;src&quot;, item.media.m ).appendTo( &quot;#images&quot; ); if ( i === 3 ) &#123; return false; &#125; &#125;); &#125;);&#125;)();&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Demo 从text.js中导入JSON数据，然后从返回的JSON数据中获得name：123$.getJSON( &quot;test.js&quot;, function( json ) &#123; console.log( &quot;JSON Data: &quot; + json.users[ 3 ].name ); &#125;); 从text.js中导入JSON数据，传递额外的数据，然后从返回的JSON数据中获得name，如果出现错误，写下错误信息：12345678$.getJSON( &quot;test.js&quot;, &#123; name: &quot;John&quot;, time: &quot;2pm&quot; &#125; ) .done(function( json ) &#123; console.log( &quot;JSON Data: &quot; + json.users[ 3 ].name ); &#125;) .fail(function( jqxhr, textStatus, error ) &#123; var err = textStatus + &quot;, &quot; + error; console.log( &quot;Request Failed: &quot; + err );&#125;); 原文请戳我","categories":[{"name":"译林","slug":"译林","permalink":"http://yoursite.com/categories/译林/"}],"tags":[]}]}